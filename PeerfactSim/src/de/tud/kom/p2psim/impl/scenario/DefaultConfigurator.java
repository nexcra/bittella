/*
 * 		    GNU GENERAL PUBLIC LICENSE
 * 		       Version 2, June 1991
 * 
 *  Copyright (C) 1989, 1991 Free Software Foundation, Inc.,
 *  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
 *  Everyone is permitted to copy and distribute verbatim copies
 *  of this license document, but changing it is not allowed.
 * 
 * 			    Preamble
 * 
 *   The licenses for most software are designed to take away your
 * freedom to share and change it.  By contrast, the GNU General Public
 * License is intended to guarantee your freedom to share and change free
 * software--to make sure the software is free for all its users.  This
 * General Public License applies to most of the Free Software
 * Foundation's software and to any other program whose authors commit to
 * using it.  (Some other Free Software Foundation software is covered by
 * the GNU Lesser General Public License instead.)  You can apply it to
 * your programs, too.
 * 
 *   When we speak of free software, we are referring to freedom, not
 * price.  Our General Public Licenses are designed to make sure that you
 * have the freedom to distribute copies of free software (and charge for
 * this service if you wish), that you receive source code or can get it
 * if you want it, that you can change the software or use pieces of it
 * in new free programs; and that you know you can do these things.
 * 
 *   To protect your rights, we need to make restrictions that forbid
 * anyone to deny you these rights or to ask you to surrender the rights.
 * These restrictions translate to certain responsibilities for you if you
 * distribute copies of the software, or if you modify it.
 * 
 *   For example, if you distribute copies of such a program, whether
 * gratis or for a fee, you must give the recipients all the rights that
 * you have.  You must make sure that they, too, receive or can get the
 * source code.  And you must show them these terms so they know their
 * rights.
 * 
 *   We protect your rights with two steps: (1) copyright the software, and
 * (2) offer you this license which gives you legal permission to copy,
 * distribute and/or modify the software.
 * 
 *   Also, for each author's protection and ours, we want to make certain
 * that everyone understands that there is no warranty for this free
 * software.  If the software is modified by someone else and passed on, we
 * want its recipients to know that what they have is not the original, so
 * that any problems introduced by others will not reflect on the original
 * authors' reputations.
 * 
 *   Finally, any free program is threatened constantly by software
 * patents.  We wish to avoid the danger that redistributors of a free
 * program will individually obtain patent licenses, in effect making the
 * program proprietary.  To prevent this, we have made it clear that any
 * patent must be licensed for everyone's free use or not licensed at all.
 * 
 *   The precise terms and conditions for copying, distribution and
 * modification follow.
 * 
 * 		    GNU GENERAL PUBLIC LICENSE
 *    TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
 * 
 *   0. This License applies to any program or other work which contains
 * a notice placed by the copyright holder saying it may be distributed
 * under the terms of this General Public License.  The "Program", below,
 * refers to any such program or work, and a "work based on the Program"
 * means either the Program or any derivative work under copyright law:
 * that is to say, a work containing the Program or a portion of it,
 * either verbatim or with modifications and/or translated into another
 * language.  (Hereinafter, translation is included without limitation in
 * the term "modification".)  Each licensee is addressed as "you".
 * 
 * Activities other than copying, distribution and modification are not
 * covered by this License; they are outside its scope.  The act of
 * running the Program is not restricted, and the output from the Program
 * is covered only if its contents constitute a work based on the
 * Program (independent of having been made by running the Program).
 * Whether that is true depends on what the Program does.
 * 
 *   1. You may copy and distribute verbatim copies of the Program's
 * source code as you receive it, in any medium, provided that you
 * conspicuously and appropriately publish on each copy an appropriate
 * copyright notice and disclaimer of warranty; keep intact all the
 * notices that refer to this License and to the absence of any warranty;
 * and give any other recipients of the Program a copy of this License
 * along with the Program.
 * 
 * You may charge a fee for the physical act of transferring a copy, and
 * you may at your option offer warranty protection in exchange for a fee.
 * 
 *   2. You may modify your copy or copies of the Program or any portion
 * of it, thus forming a work based on the Program, and copy and
 * distribute such modifications or work under the terms of Section 1
 * above, provided that you also meet all of these conditions:
 * 
 *     a) You must cause the modified files to carry prominent notices
 *     stating that you changed the files and the date of any change.
 * 
 *     b) You must cause any work that you distribute or publish, that in
 *     whole or in part contains or is derived from the Program or any
 *     part thereof, to be licensed as a whole at no charge to all third
 *     parties under the terms of this License.
 * 
 *     c) If the modified program normally reads commands interactively
 *     when run, you must cause it, when started running for such
 *     interactive use in the most ordinary way, to print or display an
 *     announcement including an appropriate copyright notice and a
 *     notice that there is no warranty (or else, saying that you provide
 *     a warranty) and that users may redistribute the program under
 *     these conditions, and telling the user how to view a copy of this
 *     License.  (Exception: if the Program itself is interactive but
 *     does not normally print such an announcement, your work based on
 *     the Program is not required to print an announcement.)
 * 
 * These requirements apply to the modified work as a whole.  If
 * identifiable sections of that work are not derived from the Program,
 * and can be reasonably considered independent and separate works in
 * themselves, then this License, and its terms, do not apply to those
 * sections when you distribute them as separate works.  But when you
 * distribute the same sections as part of a whole which is a work based
 * on the Program, the distribution of the whole must be on the terms of
 * this License, whose permissions for other licensees extend to the
 * entire whole, and thus to each and every part regardless of who wrote it.
 * 
 * Thus, it is not the intent of this section to claim rights or contest
 * your rights to work written entirely by you; rather, the intent is to
 * exercise the right to control the distribution of derivative or
 * collective works based on the Program.
 * 
 * In addition, mere aggregation of another work not based on the Program
 * with the Program (or with a work based on the Program) on a volume of
 * a storage or distribution medium does not bring the other work under
 * the scope of this License.
 * 
 *   3. You may copy and distribute the Program (or a work based on it,
 * under Section 2) in object code or executable form under the terms of
 * Sections 1 and 2 above provided that you also do one of the following:
 * 
 *     a) Accompany it with the complete corresponding machine-readable
 *     source code, which must be distributed under the terms of Sections
 *     1 and 2 above on a medium customarily used for software interchange; or,
 * 
 *     b) Accompany it with a written offer, valid for at least three
 *     years, to give any third party, for a charge no more than your
 *     cost of physically performing source distribution, a complete
 *     machine-readable copy of the corresponding source code, to be
 *     distributed under the terms of Sections 1 and 2 above on a medium
 *     customarily used for software interchange; or,
 * 
 *     c) Accompany it with the information you received as to the offer
 *     to distribute corresponding source code.  (This alternative is
 *     allowed only for noncommercial distribution and only if you
 *     received the program in object code or executable form with such
 *     an offer, in accord with Subsection b above.)
 * 
 * The source code for a work means the preferred form of the work for
 * making modifications to it.  For an executable work, complete source
 * code means all the source code for all modules it contains, plus any
 * associated interface definition files, plus the scripts used to
 * control compilation and installation of the executable.  However, as a
 * special exception, the source code distributed need not include
 * anything that is normally distributed (in either source or binary
 * form) with the major components (compiler, kernel, and so on) of the
 * operating system on which the executable runs, unless that component
 * itself accompanies the executable.
 * 
 * If distribution of executable or object code is made by offering
 * access to copy from a designated place, then offering equivalent
 * access to copy the source code from the same place counts as
 * distribution of the source code, even though third parties are not
 * compelled to copy the source along with the object code.
 * 
 *   4. You may not copy, modify, sublicense, or distribute the Program
 * except as expressly provided under this License.  Any attempt
 * otherwise to copy, modify, sublicense or distribute the Program is
 * void, and will automatically terminate your rights under this License.
 * However, parties who have received copies, or rights, from you under
 * this License will not have their licenses terminated so long as such
 * parties remain in full compliance.
 * 
 *   5. You are not required to accept this License, since you have not
 * signed it.  However, nothing else grants you permission to modify or
 * distribute the Program or its derivative works.  These actions are
 * prohibited by law if you do not accept this License.  Therefore, by
 * modifying or distributing the Program (or any work based on the
 * Program), you indicate your acceptance of this License to do so, and
 * all its terms and conditions for copying, distributing or modifying
 * the Program or works based on it.
 * 
 *   6. Each time you redistribute the Program (or any work based on the
 * Program), the recipient automatically receives a license from the
 * original licensor to copy, distribute or modify the Program subject to
 * these terms and conditions.  You may not impose any further
 * restrictions on the recipients' exercise of the rights granted herein.
 * You are not responsible for enforcing compliance by third parties to
 * this License.
 * 
 *   7. If, as a consequence of a court judgment or allegation of patent
 * infringement or for any other reason (not limited to patent issues),
 * conditions are imposed on you (whether by court order, agreement or
 * otherwise) that contradict the conditions of this License, they do not
 * excuse you from the conditions of this License.  If you cannot
 * distribute so as to satisfy simultaneously your obligations under this
 * License and any other pertinent obligations, then as a consequence you
 * may not distribute the Program at all.  For example, if a patent
 * license would not permit royalty-free redistribution of the Program by
 * all those who receive copies directly or indirectly through you, then
 * the only way you could satisfy both it and this License would be to
 * refrain entirely from distribution of the Program.
 * 
 * If any portion of this section is held invalid or unenforceable under
 * any particular circumstance, the balance of the section is intended to
 * apply and the section as a whole is intended to apply in other
 * circumstances.
 * 
 * It is not the purpose of this section to induce you to infringe any
 * patents or other property right claims or to contest validity of any
 * such claims; this section has the sole purpose of protecting the
 * integrity of the free software distribution system, which is
 * implemented by public license practices.  Many people have made
 * generous contributions to the wide range of software distributed
 * through that system in reliance on consistent application of that
 * system; it is up to the author/donor to decide if he or she is willing
 * to distribute software through any other system and a licensee cannot
 * impose that choice.
 * 
 * This section is intended to make thoroughly clear what is believed to
 * be a consequence of the rest of this License.
 * 
 *   8. If the distribution and/or use of the Program is restricted in
 * certain countries either by patents or by copyrighted interfaces, the
 * original copyright holder who places the Program under this License
 * may add an explicit geographical distribution limitation excluding
 * those countries, so that distribution is permitted only in or among
 * countries not thus excluded.  In such case, this License incorporates
 * the limitation as if written in the body of this License.
 * 
 *   9. The Free Software Foundation may publish revised and/or new versions
 * of the General Public License from time to time.  Such new versions will
 * be similar in spirit to the present version, but may differ in detail to
 * address new problems or concerns.
 * 
 * Each version is given a distinguishing version number.  If the Program
 * specifies a version number of this License which applies to it and "any
 * later version", you have the option of following the terms and conditions
 * either of that version or of any later version published by the Free
 * Software Foundation.  If the Program does not specify a version number of
 * this License, you may choose any version ever published by the Free Software
 * Foundation.
 * 
 *   10. If you wish to incorporate parts of the Program into other free
 * programs whose distribution conditions are different, write to the author
 * to ask for permission.  For software which is copyrighted by the Free
 * Software Foundation, write to the Free Software Foundation; we sometimes
 * make exceptions for this.  Our decision will be guided by the two goals
 * of preserving the free status of all derivatives of our free software and
 * of promoting the sharing and reuse of software generally.
 * 
 * 			    NO WARRANTY
 * 
 *   11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
 * FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
 * OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
 * PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
 * OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
 * TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
 * PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
 * REPAIR OR CORRECTION.
 * 
 *   12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
 * WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
 * REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
 * INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
 * OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
 * TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
 * YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
 * PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGES.
 * 
 * 		     END OF TERMS AND CONDITIONS
 * 		     
 * 		     
 * 
 * 			ADDITIONAL REQUIREMENT
 * 			
 * 1. If PeerfactSim.KOM is used for the evaluation in research publications, 
 * the following should be referenced: 
 * 
 * @MISC{PeerfactSim.KOM,
 *   title = {{PeerfactSim.KOM: A Simulator for Large-Scale Peer-to-Peer Networks}},
 *   howpublished = {http://www.peerfactsim.com}
 * }
 * 
 */

package de.tud.kom.p2psim.impl.scenario;

import java.io.File;
import java.lang.reflect.Method;
import java.util.Arrays;
import java.util.Collection;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;

import org.apache.log4j.Logger;
import org.dom4j.Attribute;
import org.dom4j.Document;
import org.dom4j.DocumentException;
import org.dom4j.Element;
import org.dom4j.io.SAXReader;

import de.tud.kom.p2psim.api.scenario.Builder;
import de.tud.kom.p2psim.api.scenario.Composable;
import de.tud.kom.p2psim.api.scenario.Configurable;
import de.tud.kom.p2psim.api.scenario.ConfigurationException;
import de.tud.kom.p2psim.api.scenario.Configurator;
import de.tud.kom.p2psim.impl.simengine.Simulator;
import de.tud.kom.p2psim.impl.util.logging.SimLogger;

/**
 * The default implementation of the configuration mechanism. The configuration is read
 * from an XML file according to following rules:
 * <ul>
 * 	  <li> TODO :)
 * </ul>
 * 
 * @author Konstantin Pussep
 * @author Sebastian Kaune
 * @version 3.0, 14.12.2007
 *
 */
public class DefaultConfigurator implements Configurator {
	protected static final String CLASS_SEPARATOR = ";";

	private static Logger log = SimLogger.getLogger(DefaultConfigurator.class);

	Map<String, Configurable> configurables = new HashMap<String, Configurable>();

	Map<String, Map<String, Configurable>> groups = new HashMap<String, Map<String, Configurable>>();

	private File configFile;

	private Map<String, String> variables = new HashMap<String, String>();

	/**
	 * Create new configurator instance with the configuration data in the given
	 * XML file.
	 * 
	 * @param file
	 *            XML config file
	 */
	public DefaultConfigurator(String file) {
		configFile = new File(file);
	}

	/**
	 * Register a specific component module by the provided name.
	 * 
	 * @param name
	 *            unique name for the component module
	 * @param component
	 *            component module
	 */
	// TODO maybe we should allow it only for internal usage in this class
	public void register(String name, Configurable component) {
		configurables.put(name, component);
	}

	/**
	 * Configure all components of the simulator. The single components are
	 * either registered via the <code>register(name, component)</code> method
	 * or specified in the config file.
	 * 
	 * @return a collection of components.
	 * @throws ConfigurationException
	 */
	public Collection<Configurable> configureAll() throws ConfigurationException {
		log.info("Configure system from file " + configFile);
		SAXReader reader = new SAXReader(false);
		try {
			Document configuration = reader.read(configFile);
			Element root = configuration.getRootElement();
			assert root.getName().equals(Configurator.CONFIGURATION_ROOT_TAG);
			// if(!parent.getName().equals(CONFIG_ROOT)){
			// throw new ConfigurationException("Bad configuration file.");
			// }
			// processComponentsSection(parent.element(COMPONENTS_SECTION));
			configureFirstLevel(root);
			return configurables.values();
		} catch (DocumentException e) {
			throw new ConfigurationException("Failed to load configuration from file " + configFile, e);
		}

	}

	/**
	 * Process the XML subtree.
	 * 
	 * @param parent
	 *            root of the subtree
	 */
	private void configureFirstLevel(Element parent) {
		if (log.isDebugEnabled())
			log.debug("Configure simulator using " + parent.asXML());
		for (Object obj : parent.elements()) {
			Element elem = (Element) obj;
			if (elem.getName().equals(Configurator.DEFAULT_TAG)) {
				for (Iterator iter = elem.elementIterator(Configurator.VARIABLE_TAG); iter.hasNext();) {
					Element variable = (Element) iter.next();
					String name = variable.attributeValue(Configurator.VARIABLE_NAME_TAG);
					String value = variable.attributeValue(Configurator.VARIABLE_VALUE_TAG);
					if (!variables.containsKey(name)) {
						// set to default only if not set yet
						variables.put(name, value);
					}
				}
			} else {
				configureComponent(elem);
			}
		}
	}

	/**
	 * Create (if not existent yet) and configure a configurable component by
	 * parsing the XML subtree.
	 * 
	 * @param elem
	 *            XML subtree with configuration data
	 * @return configured component
	 */
	public Object configureComponent(Element elem) {
		log.debug("Configure component " + elem.getName());
		Object component = configurables.get(elem.getName());
		// register new component (if not done yet)
		if (component == null) {
			component = createComponent(elem);
		}

		// configure it
		if (component != null) {
			log.info("Configure component " + component + " with element " + elem.getName());
			// component.configure(elem);
			configureAttributes(component, elem);
			// configure subcomponents
			if (component instanceof Builder) {
				log.info("Configure builder " + component);
				Builder builder = (Builder) component;
				builder.parse(elem, this);
			} else {
				for (Iterator iter = elem.elementIterator(); iter.hasNext();) {
					Element child = (Element) iter.next();
					// callMethod(getMethodName("start", child.getName()),
					// component);
					// this.builder=(Builder) component;
					processChild(component, child);
				}
			}
		} else {// component cannot be created and has not been registered
			log.warn("Skip element " + elem.getName());
		}
		return component;
	}

	private Object createComponent(Element elem) {
		if (elem.attribute("class") == null)
			return null;

		Object component;
		String className = getAttributeValue(elem.attribute("class"));
		log.debug("Create component " + className + " with element " + elem.getName());
		component = createInstance(className, elem.attributeValue("static"));
		if (component instanceof Configurable)
			register(elem.getName(), (Configurable) component);
		// composable can use other components
		if (component instanceof Composable) {
			log.debug("Compose composable " + component);
			((Composable) component).compose(this);
		}
		return component;
	}

	private Object processChild(Object component, Element child) {
		Object subcomponent = configureComponent(child);
		// String prefix = (component instanceof Builder) ? "build" : "set";

		String prefix = "set";
		String methodName = getMethodName(prefix, child.getName());
		Method[] methods = component.getClass().getMethods();
		Method match = null;
		for (int i = 0; i < methods.length; i++) {
			if (methodName.equals(methods[i].getName())) {
				match = methods[i];
				log.debug("Match " + match);
				break;
			}
		}
		if (match == null) {
			// throw new ConfigurationException("Method " + methodName + " is
			// missing in " + component);
			log.warn("Cannot set " + subcomponent + " as there is no method " + methodName + " declared in " + component);
		} else {
			Class[] types = match.getParameterTypes();
			log.debug("Param types" + Arrays.asList(types));
			if (types.length == 1) {
				try {
					match.invoke(component, types[0].cast(subcomponent));
				} catch (Exception e) {
					throw new ConfigurationException("Failed to configure " + methodName + " in " + component + " with " + subcomponent, e);
				}
			} else {
				throw new ConfigurationException("Wrong number of params for " + methodName + " in " + component);
			}
		}
		return subcomponent;
	}

	void configureAttributes(Object component, Element elem) {
		for (Iterator iter = elem.attributeIterator(); iter.hasNext();) {
			Attribute attr = (Attribute) iter.next();
			String name = attr.getName();
			if (!name.equals("class") && !name.equals("static")) {
				try {// try to configure as boolean, int, double, String, or
					// long
					String value = getAttributeValue(attr);
					// Class<String> parameterType = String.class;
					Method method = null;
					// component.getClass().getMethod(methodName,
					// parameterType);
					// log.debug("Call "+method +" on "+component);
					// method.invoke(component, new Object[]{parameterValue});

					String methodName = getMethodName("set", name);
					Class<? extends Object> classToConfigure = component.getClass();
					Method[] methods = classToConfigure.getMethods();
					for (int i = 0; i < methods.length; i++) {
						if (methods[i].getName().equals(methodName) && methods[i].getParameterTypes().length == 1) {
							if (method == null) {
								method = methods[i];
							} else {
								log.error("Found two possible methods " + method + " and " + methods[i]);
								throw new IllegalArgumentException("Cannot set property " + name + " as there are more than one matching methods in " + classToConfigure);
							}
						}
					}
					if (method == null) {
						throw new IllegalArgumentException("Cannot set property " + name + " as there are no matching method in class " + classToConfigure);
					}
					Class typeClass = method.getParameterTypes()[0];
					Object param = convertValue(value, typeClass);
					method.invoke(component, param);
					// TODO legal bool or int parameter could be string!
					// catch (NoSuchMethodException e) { invoke with string ...
				} catch (Exception e) {
					throw new ConfigurationException("Failed to set the property " + name + " in " + component, e);
				}
			}
		}

	}

	/**
	 * Automagically convert the string value to desired type. Supported types
	 * are all simple types, i.e. boolean, int, long, double.
	 * 
	 * @param value
	 * @param typeClass
	 * @return converted
	 */
	public static Object convertValue(String value, Class typeClass) {
		Object param;
		if (typeClass == boolean.class) {
			param = Boolean.valueOf(value.equalsIgnoreCase("true") || value.equalsIgnoreCase("yes"));
		} else if (typeClass == int.class) {
			param = Integer.valueOf(value);
		} else if (typeClass == long.class) {
			param = parseTime(value);
		} else if (typeClass == double.class) {
			param = Double.valueOf(value);
		} else if (typeClass == String.class) {
			param = value;
		} else if (typeClass == Class.class) {
			param = convertToClass(value);
		} else if (typeClass.isArray() && typeClass.getComponentType()==Class.class) {
			String[] valueList = value.split(CLASS_SEPARATOR);
			Class[] paramList = new Class[valueList.length];
			for (int i = 0; i < paramList.length; i++) {
				paramList[i] = convertToClass(valueList[i]);
			}
			param = paramList;
		} else {
			throw new IllegalArgumentException("Parameter type " + typeClass + " is not supported");
		}
		return param;
	}

	private static Class convertToClass(String value) {
		try {
			return  Class.forName(value);
		} catch (ClassNotFoundException e) {
			throw new IllegalArgumentException("Failed to parse class object from "+value, e);
		}
	}

	/**
	 * Can be either a variable (if starts with $) or a plain value
	 * 
	 * @param attr
	 * @return proper value
	 */
	private String getAttributeValue(Attribute attr) {
		// TODO implement some arithmetics
		String value = attr.getValue();
		value = parseValue(value);
		if (value == null)
			throw new IllegalStateException("Variable " + attr.getValue() + " has not been set");
		return value;
	}

	public String parseValue(String value) {
		if (value.contains("$")) {
			int posDollar = value.indexOf("$");
			String varName = value.substring(posDollar + 1, value.length());
			value = variables.get(varName);
			log.info("Fetched variable " + varName + " as " + value);
		}
		return value;
	}

	private String getMethodName(String prefix, String fieldName) {
		return prefix + Character.toUpperCase(fieldName.charAt(0)) + fieldName.substring(1);
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see de.tud.kom.p2psim.impl.scenario.ConfigurablesManager#getComponent(java.lang.String)
	 */
	// TODO return ComponentFactory?
	public Configurable getConfigurable(String name) {// TODO we could use
		// Classesinstead of
		// Strings for type
		// safety ...
		return configurables.get(name);
	}

	/**
	 * Get a group of component modules/factories by their group name (which is
	 * same as in the configuration file).
	 * 
	 * @param name
	 *            group's name
	 * @return mapping of module names to instances
	 */
	// public Map<String, Configurable> getGroup(String groupName){
	// return groups.get(groupName);
	// }
	/**
	 * Create an instance via the reflection of a class by using the given
	 * (full) class name and the optional method name. If the method name is
	 * null, the default constructor will be used. The method's signature should
	 * have no arguments.
	 * 
	 * @param className
	 * @param staticMethod
	 * @return create instance
	 * @throws ConfigurationException
	 */
	private Object createInstance(String className, String staticMethod) throws ConfigurationException {
		try {
			Class forName = Class.forName(className);
			Object component;
			if (staticMethod == null)
				component = forName.newInstance();
			else
				component = forName.getDeclaredMethod(staticMethod, new Class[0]).invoke(null, new Object[0]);
			return component;
		} catch (Exception e) {
			log.error(e);
			throw new ConfigurationException("Failed to create configurable " + className, e);
		}
	}

	/**
	 * Set variables with values which replace the variable names in the
	 * configuration file. Default values will be overwritten.
	 * 
	 * @param variables
	 */
	public void setVariables(Map<String, String> variables) {
		if (variables.size() != 0)
			log.warn("Set variables " + variables);
		this.variables.putAll(variables);
	}

	/**
	 * Parse the time according to the following rule: <code>value</code>
	 * is a number followed by a "ms", "s", "m" or "h" for milliseconds, seconds etc.. 
	 * The conversion is done according to the constants defined in the {@link Simulator} class.
	 * 
	 * @param value - time value to parse
	 * @return parsed value
	 */
	public static long parseTime(String value) {
		if (value.matches("\\d+(ms|s|m|h)")) {
			String number;
			long factor;
			if (value.matches("\\d+(ms)")) {
				number = value.substring(0, value.length() - 2);
				factor = Simulator.MILLISECOND_UNIT;
			} else {
				number = value.substring(0, value.length() - 1);
				factor = 1;
				char unit = value.charAt(value.length() - 1);
				switch (unit) {
				case 'h':
					factor *= 60;
				case 'm':
					factor *= 60;
				case 's':
					factor *= Simulator.SECOND_UNIT;
					break;
				default:
					throw new IllegalStateException("time unit " + unit + " is not allowed");
				}
			}
			return factor * Long.valueOf(number);
		}
		return Long.valueOf(value);
	}
}
